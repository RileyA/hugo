package hugo

import (
	"bytes"
	"encoding/json"
	"errors"
	"io/ioutil"
	"net/http"
	"strconv"
)

// Represents a single Philips Hue Hub.
//
// This is the object that we'll interact with to set/get lightbulb state.
//
// See: http://www.developers.meethue.com/philips-hue-api For detailed docs
// on the RESTful API.
type Hub struct {
	httpAddress   string
	username      string
	authenticated bool
	Lights        map[string]Light
}

type HueError struct {
	Type        int    `json:"type"`
	Address     string `json:"address"`
	Description string `json:"description"`
}

type HueSuccess struct {
	Username string `json:"username"`
}

/////////////////////////////////////////////////////////////////////////////
// Initialize a hub with the specified address. See hugo.FindHubAddresses()
// in discovery.go to find hub addresses.
func CreateHubWithAddress(address HubAddress) *Hub {
	httpAddress := "http://" + address.InternalIpAddress + "/api"
	username := ""
	authenticated := false
	return &Hub{httpAddress, username, authenticated, nil}
}

/////////////////////////////////////////////////////////////////////////////
// Check whether this hub is currently authenticated.
func (hub *Hub) IsAuthenticated() (bool, error) {
	response, err := http.Get(hub.httpAddress + "/" + hub.username)
	if err != nil {
		return false, err
	}
	defer response.Body.Close()

	_, hueErrors, err := parseHueResponses(response)

	if err != nil {
		return false, err
	}

	if hueErrors == nil {
		return true, nil
	}

	return false, nil
}

/////////////////////////////////////////////////////////////////////////////
// Try to authenticate with a provided username.
// Returns nil on success.
func (hub *Hub) AuthenticateExistingUser(username string) error {
	if username == "" {
		return errors.New("No username chosen.")
	}

	// We're already confirmed to be authenticated; early-out.
	if hub.username == username && hub.authenticated {
		return nil
	}

	hub.username = username

	authenticated, err := hub.IsAuthenticated()
	if err != nil {
		return err
	}

	if !authenticated {
		return errors.New("Username: " + username + " could not be authenticated.")
	}

	hub.authenticated = true
	err = hub.getLightStates()
	if err != nil {
		return err
	}
	return nil
}

/////////////////////////////////////////////////////////////////////////////
// Try to authenticate a new usermame with the specified device string.
//
// 'devicetype' should be in the form: <application_name>#<devicename>
//
// If a press of the hub button is necessary, prom
//
// On success, returns the username generated by the hub, promptButtonPress()
// will be called to ask the user to do so, and block until the button has been
// pressed.
func (hub *Hub) AuthenticateNewUser(deviceType string, promptButtonPress func()) (string, error) {
	// We're already confirmed to be authenticated; early-out.
	if hub.authenticated {
		return hub.username, nil
	}

	postBody := []byte("{\"devicetype\": \"" + deviceType + "\"}")
	response, err := http.Post(hub.httpAddress, "application/json", bytes.NewBuffer(postBody))
	if err != nil {
		return "", err
	}

	hueSuccesses, hueErrors, err := parseHueResponses(response)
	response.Body.Close()

	if err != nil {
		return "", err
	}

	if len(hueSuccesses) == 0 {
		for _, hueError := range hueErrors {
			if hueError.Type == 101 {
				promptButtonPress()
			} else {
				return "", errors.New("Unexpected hue error: " + strconv.Itoa(hueError.Type) + ": " + hueError.Description)
			}
		}
		// Try again, hopefully the button has been pressed...
		response, err := http.Post(hub.httpAddress, "application/json", bytes.NewBuffer(postBody))
		hueSuccesses, hueErrors, err = parseHueResponses(response)
		if err != nil {
			return "", err
		}
	}

	if len(hueSuccesses) != 1 || len(hueErrors) > 0 {
		return "", errors.New("Failed to authenticate new user, did you press the hub button within 30 seconds?")
	}

	err = hub.getLightStates()
	if err != nil {
		return "", err
	}

	hub.username = hueSuccesses[0].Username
	return hueSuccesses[0].Username, nil
}

/////////////////////////////////////////////////////////////////////////////
// Set the state of a light by id.
func (hub *Hub) SetLightState(id string, state LightState) error {
	if !hub.authenticated {
		return errors.New("Haven't authenticated with hub.")
	}
	if _, ok := hub.Lights[id]; !ok {
		return errors.New("No light with 'id': " + id)
	}
	if light, _ := hub.Lights[id]; !light.State.Reachable {
		return errors.New("Light with 'id': " + id + " is unreachable.")
	}
	marshalledState, err := json.Marshal(state)
	if err != nil {
		return err
	}
	request, err := http.NewRequest("PUT", hub.httpAddress+"/"+hub.username+"/lights/"+id+"/state", nil)
	request.Body = ioutil.NopCloser(bytes.NewBuffer(marshalledState))
	client := &http.Client{}
	response, err := client.Do(request)
	// TODO(rileya): Report errors here.
	response.Body.Close()
	return nil
}

/////////////////////////////////////////////////////////////////////////////
// Get the current state of all connected lights.
func (hub *Hub) getLightStates() error {
	response, err := http.Get(hub.httpAddress + "/" + hub.username + "/lights")
	if err != nil {
		return err
	}
	defer response.Body.Close()
	bodyContents, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return err
	}
	err = json.Unmarshal(bodyContents, &hub.Lights)
	if err != nil {
		return err
	}

	return nil
}

/////////////////////////////////////////////////////////////////////////////
// If response is a hue error/success response, in the format:
//
// [{"error": {...}},{"error": {...},...]
// or
// [{"success": {...}}]
//
// This returns arrays of each error and success object.
func parseHueResponses(response *http.Response) ([]HueSuccess, []HueError, error) {
	bodyContents, err := ioutil.ReadAll(response.Body)

	var errorList []json.RawMessage
	err = json.Unmarshal(bodyContents, &errorList)

	if err != nil {
		return nil, nil, nil
	}

	var hueErrors []HueError
	var hueSuccesses []HueSuccess

	for _, errorObject := range errorList {
		var resultMap map[string]json.RawMessage
		err = json.Unmarshal(errorObject, &resultMap)
		if err != nil {
			return nil, nil, err
		}

		if resultMap["error"] != nil {
			var errorInfo HueError
			json.Unmarshal(resultMap["error"], &errorInfo)
			if err != nil {
				return nil, nil, err
			}
			hueErrors = append(hueErrors, errorInfo)
		}

		if resultMap["success"] != nil {
			var successInfo HueSuccess
			json.Unmarshal(resultMap["success"], &successInfo)
			if err != nil {
				return nil, nil, err
			}
			hueSuccesses = append(hueSuccesses, successInfo)
		}
	}

	return hueSuccesses, hueErrors, nil
}
